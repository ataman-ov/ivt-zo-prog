# Контрольные вопросы [ОТЧЕТ]:
### 1. Как в C# .NET может быть представлена строка символов?
В C# .NET строка символов представляется с помощью класса String. Строки в C# являются неизменяемыми (immutable), что означает, что после создания строки ее содержимое не может быть изменено. Если необходимо изменить строку, создается новая строка с изменениями. Строки могут быть объявлены с использованием двойных кавычек:
```
string myString = "Hello, World!";
```
### 2. Кратко опишите особенности и основные методы класса String.
- **Неизменяемость:** Как уже упоминалось, строки в C# являются неизменяемыми. Любые операции, которые кажутся изменяющими строку, на самом деле создают новую строку.

- **Сравнение строк:** Строки могут быть сравнены с учетом регистра и без учета регистра с помощью методов String.Compare и String.Equals.

- **Методы класса String:**

**Length:** Возвращает количество символов в строке.
**Substring(int startIndex, int length):** Возвращает подстроку, начиная с указанного индекса и заданной длины.
**IndexOf(string value):** Возвращает индекс первого вхождения указанной подстроки.
**ToUpper():** Преобразует строку в верхний регистр.
**ToLower():** Преобразует строку в нижний регистр.
**Trim():** Удаляет пробелы в начале и конце строки.
**Split(char[] separator):** Разделяет строку на подстроки по указанным разделителям.
**Join(string separator, string[] values):** Объединяет массив строк в одну строку, используя указанный разделитель.

### 3. Что делают методы split() и join()?
- **Split():** Метод Split разбивает строку на массив подстрок, используя указанные разделители. Например:
```
string sentence = "Hello, World!";
string[] words = sentence.Split(' '); // Разделяет строку по пробелу
```
- **Join():** Метод Join объединяет массив строк в одну строку, используя указанный разделитель. Например:
```
string[] words = { "Hello", "World" };
string sentence = string.Join(", ", words); // Результат: "Hello, World"
```
### 4. Укажите особенности сравнения строк в C# .NET.
- **Регистронезависимое и регистрозависимое сравнение:** В C# строки могут быть сравнены с учетом регистра (метод String.Compare) или без учета регистра (метод String.Equals с параметром StringComparison.OrdinalIgnoreCase).

- **Сравнение по значению:** Строки сравниваются по значению, а не по ссылке. Это означает, что две строки с одинаковым содержимым будут считаться равными, даже если они находятся в разных местах памяти.

- **Сравнение с использованием ==:** Оператор == также может использоваться для сравнения строк, и он будет работать корректно, сравнивая значения строк.

### 5. Что такое абстрактное синтаксическое дерево? Дерево разбора?
- **Абстрактное синтаксическое дерево (AST):** Это структура данных, представляющая синтаксическую структуру исходного кода. В AST узлы представляют конструкции языка программирования, такие как выражения, операторы и операнды. AST используется в компиляторах и интерпретаторах для анализа и оптимизации кода.

- **Дерево разбора (Parse Tree):** Это более детализированная структура, которая показывает, как входной код соответствует грамматике языка. Узлы дерева разбора представляют правила грамматики, а листья представляют токены (лексемы). Дерево разбора может быть преобразовано в абстрактное синтаксическое дерево, которое упрощает анализ и обработку кода.

В общем, AST и дерево разбора используются в компиляторах и интерпретаторах для анализа и обработки исходного кода, но AST более абстрактно и упрощает структуру, в то время как дерево разбора более детализировано и соответствует грамматике языка.

### 6. Приведите определение и пример РБНФ-выражения.
**РБНФ (Рекурсивная Бэкусовская Нормальная Форма)** — это формализм, используемый для описания синтаксиса языков программирования и других формальных языков. РБНФ позволяет описывать грамматику языка с помощью правил, где каждая строка состоит из символов и нетерминалов.

**Пример РБНФ-выражения:**

Рассмотрим простую грамматику для описания арифметических выражений:
```
<expression> ::= <term> | <expression> + <term> | <expression> - <term>
<term> ::= <factor> | <term> * <factor> | <term> / <factor>
<factor> ::= <number> | ( <expression> )
<number> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```
В этом примере 
```
<expression>, <term>, <factor>, и <number> — это нетерминалы, а +, -, *, /, (, )
```
и цифры — терминалы.

### 7. Что такое регулярные выражения? Для чего они используются?
**Регулярные выражения** — это последовательности символов, которые формируют шаблоны для поиска и манипуляции текстом. Они используются для:

- Поиска и замены текста.
- Валидации форматов данных (например, адресов электронной почты, номеров телефонов).
- Извлечения подстрок из текста.
- Разделения строк на основе шаблонов.
Регулярные выражения позволяют описывать сложные условия поиска с помощью компактного синтаксиса.

### 8. Опишите основные синтаксические элементы регулярных выражений.
Основные синтаксические элементы регулярных выражений включают:

- **Литералы:** Простые символы, которые соответствуют самим себе (например, a, 1, @).
- **Классы символов:** Указываются в квадратных скобках и соответствуют любому одному символу из указанного набора (например, [abc] соответствует a, b или c).
**Квантификаторы:**
- * — соответствует 0 или более вхождениям предыдущего элемента.
- + — соответствует 1 или более вхождениям предыдущего элемента.
- ? — соответствует 0 или 1 вхождению предыдущего элемента.
- {n} — соответствует ровно n вхождениям.
- {n,} — соответствует n или более вхождениям.
- {n,m} — соответствует от n до m вхождениям.
**Специальные символы:**
- . — соответствует любому символу, кроме символа новой строки.
- ^ — соответствует началу строки.
- $ — соответствует концу строки.
**Группировка:** Используется для объединения нескольких элементов в одну группу с помощью круглых скобок (например, (abc)).
**Альтернатива:** Используется для указания выбора между несколькими вариантами с помощью вертикальной черты (например, a|b соответствует a или b).

### 9. Укажите разницу между «жадными», «ленивыми» и «собственническими» квантификаторами в регулярных выражениях.
- **Жадные квантификаторы:** По умолчанию квантификаторы в регулярных выражениях являются жадными. Это означает, что они пытаются захватить как можно больше символов. Например, в выражении .* будет захвачено все, что возможно, включая символы новой строки, если это разрешено.

- **Ленивые квантификаторы:** Ленивые квантификаторы (или не жадные) пытаются захватить как можно меньше символов, чтобы соответствовать остальной части выражения. Они обозначаются добавлением знака вопроса после жадного квантификатора. Например, .*? будет захватывать минимально возможное количество символов.

- **Собственнические квантификаторы:** Собственнические квантификаторы (или "жадные" квантификаторы) работают аналогично жадным, но они не позволяют другим квантификаторам захватывать символы. Они обозначаются с помощью `
